
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
<style>
   BODY {background-color: white; 
         font-size: 10pt; font-family: verdana,helvetica;}
   A  {text-decoration: none;color: blue}
</style>
</head>
<body>

<a name='SCF'</a>
<H2>SCF</H2>


<p><b><a name='CalcEigenvalues'></a>CalcEigenvalues</b>
<br/><i>Section</i>: SCF
<br/><i>Type</i>: logical
<br/><i>Default</i>: yes
<br/><br> (Experimental) When this variable is set to <tt>no</tt>,
 Octopus will not calculate the eigenvalues or eigenvectors of
 the Hamiltonian. Instead, Octopus will obtain the occupied
 subspace. The advantage that calculation can be made faster by
 avoiding subspace diagonalization and other calculations.
<br><br>
 This mode cannot be used with unoccupied states.

</p><hr width='30%' align='left'/>


<p><b><a name='SCFCalculateDipole'></a>SCFCalculateDipole</b>
<br/><i>Section</i>: SCF
<br/><i>Type</i>: logical
<br/><br> This variable controls whether the dipole is calculated at the
 end of a self-consistent iteration. For finite systems the
 default is yes. For periodic systems the default is no, unless
 an electric field is being applied in a periodic direction.
 The single-point Berry`s phase approximation is used for
 periodic directions. Ref:
 E Yaschenko, L Fu, L Resca, and R Resta, <i>Phys. Rev. B</i> <b>58</b>, 1222-1229 (1998).

</p><hr width='30%' align='left'/>


<p><b><a name='SCFCalculateForces'></a>SCFCalculateForces</b>
<br/><i>Section</i>: SCF
<br/><i>Type</i>: logical
<br/><br> This variable controls whether the forces on the ions are
 calculated at the end of a self-consistent iteration. The
 default is yes, unless the system only has user-defined
 species.

</p><hr width='30%' align='left'/>


<p><b><a name='SCFCalculatePartialCharges'></a>SCFCalculatePartialCharges</b>
<br/><i>Section</i>: SCF
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> (Experimental) This variable controls whether partial charges
 are calculated at the end of a self-consistent iteration.

</p><hr width='30%' align='left'/>


<p><b><a name='SCFCalculateStress'></a>SCFCalculateStress</b>
<br/><i>Section</i>: SCF
<br/><i>Type</i>: logical
<br/><br> This variable controls whether the stress on the lattice is
 calculated at the end of a self-consistent iteration. The
 default is no.

</p><hr width='30%' align='left'/>


<p><b><a name='SCFinLCAO'></a>SCFinLCAO</b>
<br/><i>Section</i>: SCF
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> Performs the SCF cycle with the calculation restricted to the LCAO subspace.
 This may be useful for systems with convergence problems (first do a
 calculation within the LCAO subspace, then restart from that point for
 an unrestricted calculation).

</p><hr width='30%' align='left'/>

<a name='SCF::Convergence'</a>
<H2>SCF::Convergence</H2>


<p><b><a name='ConvAbsDens'></a>ConvAbsDens</b>
<br/><i>Section</i>: SCF::Convergence
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> Absolute convergence of the density:
<br><br>
 \(\varepsilon = \int {\rm d}^3r \left| \rho^{out}(\bf r) -\rho^{inp}(\bf r) \right|\).
<br><br>
 A zero value (the default) means do not use this criterion.

</p><hr width='30%' align='left'/>


<p><b><a name='ConvAbsEv'></a>ConvAbsEv</b>
<br/><i>Section</i>: SCF::Convergence
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> Absolute convergence of the sum of the eigenvalues:
<br><br>
 \( \varepsilon = \left| \sum_{j=1}^{N_{occ}} \varepsilon_j^{out} -
 \sum_{j=1}^{N_{occ}} \varepsilon_j^{inp} \right| \)
<br><br>
 A zero value (the default) means do not use this criterion.

</p><hr width='30%' align='left'/>


<p><b><a name='ConvEigenError'></a>ConvEigenError</b>
<br/><i>Section</i>: SCF::Convergence
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> If true, the calculation will not be considered converged unless all states have
 individual errors less than <tt>EigensolverTolerance</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='ConvEnergy'></a>ConvEnergy</b>
<br/><i>Section</i>: SCF::Convergence
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> Stop the SCF when the magnitude of change in energy during at
 one SCF iteration is smaller than this value.
<br><br>

</p><hr width='30%' align='left'/>


<p><b><a name='ConvForce'></a>ConvForce</b>
<br/><i>Section</i>: SCF::Convergence
<br/><i>Type</i>: float
<br/><br> Absolute convergence of the forces: maximum variation of any
 component of the ionic forces in consecutive iterations.  A
 zero value means do not use this criterion. The default is
 zero, except for geometry optimization, which sets a default of
 1e-8 H/b.

</p><hr width='30%' align='left'/>


<p><b><a name='ConvRelDens'></a>ConvRelDens</b>
<br/><i>Section</i>: SCF::Convergence
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-5
<br/><br> Relative convergence of the density:
<br><br>
 \(\varepsilon = \frac{1}{N} \mathrm{ConvAbsDens}\).
<br><br>
 <i>N</i> is the total number of electrons in the problem.  A
 zero value means do not use this criterion.

</p><hr width='30%' align='left'/>


<p><b><a name='ConvRelEv'></a>ConvRelEv</b>
<br/><i>Section</i>: SCF::Convergence
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> Relative convergence of the sum of the eigenvalues:
<br><br>
 \(\varepsilon = \frac{ \left| \sum_{j=1}^{N_{occ}} ( \varepsilon_j^{out} -  \varepsilon_j^{inp} ) \right|}
 {\left| \sum_{j=1}^{N_{occ}} \varepsilon_j^{out} \right|} \)
<br><br>

</p><hr width='30%' align='left'/>


<p><b><a name='MaximumIter'></a>MaximumIter</b>
<br/><i>Section</i>: SCF::Convergence
<br/><i>Type</i>: integer
<br/><i>Default</i>: 200
<br/><br> Maximum number of SCF iterations. The code will stop even if convergence
 has not been achieved. -1 means unlimited.
 0 means just do LCAO (or read from restart), compute the eigenvalues and energy,
 and stop, without updating the wavefunctions or density.

</p><hr width='30%' align='left'/>


<p><b><a name='MaximumIterBerry'></a>MaximumIterBerry</b>
<br/><i>Section</i>: SCF::Convergence
<br/><i>Type</i>: integer
<br/><i>Default</i>: 10
<br/><br> Maximum number of iterations for the Berry potential, within each SCF iteration.
 Only applies if a <tt>StaticElectricField</tt> is applied in a periodic direction.
 The code will move on to the next SCF iteration even if convergence
 has not been achieved. -1 means unlimited.

</p><hr width='30%' align='left'/>

<a name='SCF::Eigensolver'</a>
<H2>SCF::Eigensolver</H2>


<p><b><a name='Eigensolver'></a>Eigensolver</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: integer
<br/><br> Which eigensolver to use to obtain the lowest eigenvalues and
 eigenfunctions of the Kohn-Sham Hamiltonian. The default is
 conjugate gradients (<tt>cg</tt>), except that when parallelization in states is
 enabled, the default is <tt>lobpcg</tt>.

<br/><i>Options</i>:
<ul>
<li><b>rmmdiis</b>:  Residual minimization scheme, direct inversion in the
 iterative subspace eigensolver, based on the implementation of
 Kresse and Furthm&uuml;ller [<i>Phys. Rev. B</i> <b>54</b>, 11169
 (1996)]. This eigensolver requires almost no orthogonalization
 so it can be considerably faster than the other options for
 large systems; however it might suffer stability problems. To
 improve its performance a large number of <tt>ExtraStates</tt>
 are required (around 10-20% of the number of occupied states).
 Note: with <tt>unocc</tt>, you will need to stop the calculation
 by hand, since the highest states will probably never converge.
 Usage with more than one block of states per node is experimental, unfortunately.
</li>
<li><b>plan</b>:  Preconditioned Lanczos scheme. Ref: Y. Saad, A. Stathopoulos, J. Chelikowsky, K. Wu and S. Ogut,
 "Solution of Large Eigenvalue Problems in Electronic Structure Calculations", <i>BIT</i> <b>36</b>, 1 (1996).
</li>
<li><b>arpack</b>:  (Experimental) Implicitly Restarted Arnoldi Method. Requires the ARPACK package.
</li>
<li><b>feast</b>:  (Experimental) Non-Hermitian FEAST eigensolver. Requires the FEAST package.
</li>
<li><b>psd</b>:  (Experimental) Precondtioned steepest descent optimization of the eigenvectors.
</li>
<li><b>cg</b>:  Conjugate-gradients algorithm.
</li>
<li><b>cg_new</b>:  An alternative conjugate-gradients eigensolver, faster for
 larger systems but less mature.
 Ref: Jiang et al., <i>Phys. Rev. B</i> <b>68</b>, 165337 (2003)
</li>
<li><b>lobpcg</b>:  (Experimental) Locally optimal block-preconditioned
 conjugate-gradient algorithm. Ref: A. Knyazev, Toward the
 Optimal Preconditioned Eigensolver: Locally Optimal Block
 Preconditioned Conjugate Gradient Method, <i>SIAM Journal on
 Scientific Computing</i>, 23(2):517-541, 2001.
</li>
<li><b>evolution</b>:  (Experimental) Propagation in imaginary time.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='EigensolverArnoldiVectors'></a>EigensolverArnoldiVectors</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: integer
<br/><br> For <tt>Eigensolver = arpack</tt>, this indicates how many Arnoldi vectors are generated.
 It must satisfy <tt>EigensolverArnoldiVectors</tt> - Number Of Eigenvectors >= 2.
 See the ARPACK documentation for more details. It will default to
 twice the number of eigenvectors (which is the number of states)

</p><hr width='30%' align='left'/>


<p><b><a name='EigensolverImaginaryTime'></a>EigensolverImaginaryTime</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: float
<br/><i>Default</i>: 10.0
<br/><br> The imaginary-time step that is used in the imaginary-time evolution
 method (<tt>Eigensolver = evolution</tt>) to obtain the lowest eigenvalues/eigenvectors.
 It must satisfy <tt>EigensolverImaginaryTime > 0</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EigensolverMaxIter'></a>EigensolverMaxIter</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: integer
<br/><br> Determines the maximum number of iterations that the
 eigensolver will perform if the desired tolerance is not
 achieved. The default is 25 iterations for all eigensolvers
 except for <tt>rmdiis</tt>, which performs only 3 iterations (only
 increase it if you know what you are doing).

</p><hr width='30%' align='left'/>


<p><b><a name='EigensolverMinimizationIter'></a>EigensolverMinimizationIter</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: integer
<br/><i>Default</i>: 5
<br/><br> During the first iterations, the RMMDIIS eigensolver requires
 some steepest-descent minimizations to improve
 convergence. This variable determines the number of those
 minimizations.

</p><hr width='30%' align='left'/>


<p><b><a name='EigensolverSaveMemory'></a>EigensolverSaveMemory</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> The RMMDIIS eigensolver may require a considerable amount of
 extra memory. When this variable is set to yes, the
 eigensolver will use less memory at the expense of some
 performance. This is especially useful for GPUs.

</p><hr width='30%' align='left'/>


<p><b><a name='EigensolverSkipKpoints'></a>EigensolverSkipKpoints</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: logical
<br/><br> Only solve Hamiltonian for k-points with zero weight

</p><hr width='30%' align='left'/>


<p><b><a name='EigensolverTolerance'></a>EigensolverTolerance</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: float
<br/><br> This is the tolerance for the eigenvectors. The default is 1e-6,
 except for the ARPACK solver for which it is 0.

</p><hr width='30%' align='left'/>


<p><b><a name='Preconditioner'></a>Preconditioner</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: integer
<br/><br> Which preconditioner to use in order to solve the Kohn-Sham
 equations or the linear-response equations. The default is
 pre_filter, except for curvilinear coordinates, where no
 preconditioner is applied by default.

<br/><i>Options</i>:
<ul>
<li><b>no</b>:  Do not apply preconditioner.
</li>
<li><b>pre_filter</b>:  Filter preconditioner.
</li>
<li><b>pre_jacobi</b>:  Jacobi preconditioner. Only the local part of the pseudopotential is used.
 Not very helpful.
</li>
<li><b>pre_poisson</b>:  Uses the full Laplacian as preconditioner. The inverse is calculated through
 the solution of the Poisson equation. This is, of course, very slow.
</li>
<li><b>pre_multigrid</b>:  Multigrid preconditioner.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='PreconditionerFilterFactor'></a>PreconditionerFilterFactor</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: float
<br/><br> This variable controls how much filter preconditioner is
 applied. A value of 1.0 means no preconditioning, 0.5 is the
 standard.
<br><br>
 The default is 0.5, except for periodic systems where the
 default is 0.6.
<br><br>
 If you observe that the first eigenvectors are not converging
 properly, especially for periodic systems, you should
 increment this value.

</p><hr width='30%' align='left'/>


<p><b><a name='StatesOrthogonalization'></a>StatesOrthogonalization</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: integer
<br/><br> The full orthogonalization method used by some
 eigensolvers. The default is <tt>cholesky_serial</tt>, except with state
 parallelization, the default is <tt>cholesky_parallel</tt>.

<br/><i>Options</i>:
<ul>
<li><b>cholesky_serial</b>:  Cholesky decomposition implemented using
 BLAS/LAPACK. Can be used with domain parallelization but not
 state parallelization. (Obsolete synonym: <tt>gram_schmidt</tt>)
</li>
<li><b>cholesky_parallel</b>:  Cholesky decomposition implemented using
 ScaLAPACK. Compatible with states parallelization. (Obsolete synonym: <tt>par_gram_schmidt</tt>)
</li>
<li><b>mgs</b>:  Modified Gram-Schmidt orthogonalization.
 Can be used with domain parallelization but not state parallelization.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='SubspaceDiagonalization'></a>SubspaceDiagonalization</b>
<br/><i>Section</i>: SCF::Eigensolver
<br/><i>Type</i>: integer
<br/><i>Default</i>: standard
<br/><br> Selects the method to perform subspace diagonalization. The
 default is <tt>standard</tt>, unless states parallelization is used,
 when the default is <tt>scalapack</tt>.

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  No subspace diagonalization. WARNING: this will generally give incorrect results.
</li>
<li><b>standard</b>:  The standard routine. Can be used with domain parallelization but not
 state parallelization.
</li>
<li><b>scalapack</b>:  State-parallelized version using ScaLAPACK. (Requires that
 Octopus was compiled with ScaLAPACK support.)
</li>
</ul>
</p><hr width='30%' align='left'/>

<a name='SCF::Eigensolver::ARPACK'</a>
<H2>SCF::Eigensolver::ARPACK</H2>


<p><b><a name='ArpackInitialTolerance'></a>ArpackInitialTolerance</b>
<br/><i>Section</i>: SCF::Eigensolver::ARPACK
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> Use this tolerance in Arpack when the relative density error is
 approximately 1. As the relative density error becomes lower,
 use a tolerance in between this value and <tt>EigenSolverTolerance</tt>.
 approaching the latter as the SCF cycle converges. This
 parameter is ignored if given a non-positive value (default).
 In that case <tt>EigenSolverTolerance</tt> is used always.

</p><hr width='30%' align='left'/>


<p><b><a name='EigensolverArpackInitialResid'></a>EigensolverArpackInitialResid</b>
<br/><i>Section</i>: SCF::Eigensolver::ARPACK
<br/><i>Type</i>: integer
<br/><i>Default</i>: constant
<br/><br> Initial residual vector.

<br/><i>Options</i>:
<ul>
<li><b>rand</b>:  Random residual vector.
</li>
<li><b>calc</b>:  \(resid = H \psi - \varepsilon \psi\).
</li>
<li><b>constant</b>:  Initial residual vector constant = 1.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='EigensolverArpackSort'></a>EigensolverArpackSort</b>
<br/><i>Section</i>: SCF::Eigensolver::ARPACK
<br/><i>Type</i>: string
<br/><i>Default</i>: SR
<br/><br> Eigenvalue sorting strategy (case sensitive).
 From ARPACK documentation:
 <ul>
 <li>'LM' -> want eigenvalues of largest magnitude.
 <li>'SM' -> want eigenvalues of smallest magnitude.
 <li>'LR' -> want eigenvalues of largest real part.
 <li>'SR' -> want eigenvalues of smallest real part.
 <li>'LI' -> want eigenvalues of largest imaginary part.
 <li>'SI' -> want eigenvalues of smallest imaginary part.
 </ul>

</p><hr width='30%' align='left'/>


<p><b><a name='EigensolverParpack'></a>EigensolverParpack</b>
<br/><i>Section</i>: SCF::Eigensolver::ARPACK
<br/><i>Type</i>: logical
<br/><br> Use Parallel ARPACK. Default is true if parallel in domains. Code must have been built with
 PARPACK support. Only relevant if <tt>Eigensolver = arpack</tt>. Even more experimental than ARPACK.

</p><hr width='30%' align='left'/>

<a name='SCF::Eigensolver::FEAST'</a>
<H2>SCF::Eigensolver::FEAST</H2>


<p><b><a name='FeastContour'></a>FeastContour</b>
<br/><i>Section</i>: SCF::Eigensolver::FEAST
<br/><i>Type</i>: block
<br/><br> A list of points tracing out a complex contour within which FEAST will
 search for eigenvalues.  Each row is one point.  Real and imaginary
 parts are read from first and second column respectively.  For now,
 points will be joined by straight line segments.
<br><br>
 Note: Contour must have negative orientation!

</p><hr width='30%' align='left'/>


<p><b><a name='FeastMaxIter'></a>FeastMaxIter</b>
<br/><i>Section</i>: SCF::Eigensolver::FEAST
<br/><i>Type</i>: integer
<br/><i>Default</i>: 20
<br/><br> Maximum number of extra iterations that the FEAST eigensolver
 will perform per SCF step.  Must be >= 0.  0 means that only
 one iteration will be done.

</p><hr width='30%' align='left'/>

<a name='SCF::LCAO'</a>
<H2>SCF::LCAO</H2>


<p><b><a name='AtomsMagnetDirection'></a>AtomsMagnetDirection</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: block
<br/><br> This option is only used when <tt>GuessMagnetDensity</tt> is
 set to <tt>user_defined</tt>. It provides a direction for the
 magnetization vector of each atom when building the guess
 density. In order to do that, the user should specify the
 coordinates of a vector that has the desired direction and
 norm.  Note that it is necessary to maintain the ordering in
 which the species were defined in the coordinates
 specifications.
<br><br>
 For spin-polarized calculations, the vectors should have only
 one component; for non-collinear-spin calculations, they
 should have three components. If the norm of the vector is greater
 than the number of valence electrons in the atom, it will be rescaled
 to this number, which is the maximum possible magnetization.

</p><hr width='30%' align='left'/>


<p><b><a name='GuessMagnetDensity'></a>GuessMagnetDensity</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: integer
<br/><i>Default</i>: ferromagnetic
<br/><br> The guess density for the SCF cycle is just the sum of all the atomic densities.
 When performing spin-polarized or non-collinear-spin calculations this option sets
 the guess magnetization density.
<br><br>
 For anti-ferromagnetic configurations, the <tt>user_defined</tt> option should be used.
<br><br>
 Note that if the <tt>paramagnetic</tt> option is used, the final ground state will also be
 paramagnetic, but the same is not true for the other options.

<br/><i>Options</i>:
<ul>
<li><b>paramagnetic</b>:  Magnetization density is zero.
</li>
<li><b>ferromagnetic</b>:  Magnetization density is the sum of the atomic magnetization densities.
</li>
<li><b>random</b>:  Each atomic magnetization density is randomly rotated.
</li>
<li><b>user_defined</b>:  The atomic magnetization densities are rotated so that the magnetization
 vector has the same direction as a vector provided by the user. In this case,
 the <tt>AtomsMagnetDirection</tt> block has to be set.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='LCAOAlternative'></a>LCAOAlternative</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> If this variable is set, the LCAO procedure will use an
 alternative (and experimental) implementation. It is faster for
 large systems and parallel in states. It is not working for spinors, however.

</p><hr width='30%' align='left'/>


<p><b><a name='LCAOComplexYlms'></a>LCAOComplexYlms</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> If set to true, and using complex states, complex spherical harmonics will be used, <i>i.e.</i>
 with \(e^{\pm i m \phi}\).
 If false, real spherical harmonics with \(\sin(m \phi)\) or \(\cos(m \phi)\) are used.
 This variable will make it more likely to get states that are eigenvectors of the \(L_z\)
 operator, with a definite angular momentum.

</p><hr width='30%' align='left'/>


<p><b><a name='LCAODiagTol'></a>LCAODiagTol</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-10
<br/><br> Only applies if <tt>LCAOAlternative = true</tt>.
 The tolerance for the diagonalization of the LCAO Hamiltonian.

</p><hr width='30%' align='left'/>


<p><b><a name='LCAODimension'></a>LCAODimension</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: integer
<br/><br> (Only applies if <tt>LCAOAlternative = no</tt>.)
 Before starting the SCF cycle, an initial LCAO calculation can be performed
 in order to obtain reasonable initial guesses for spin-orbitals and densities.
 For this purpose, the code calculates a number of atomic orbitals.
 The number available for a species described by a pseudopotential is all the
 orbitals up the maximum angular momentum in the pseudopotential, minus any orbitals that
 are found to be unbound. For non-pseudopotential species, the number is equal to
 twice the valence charge.
 The default dimension for the LCAO basis
 set will be the sum of all these numbers, or twice the number of required orbitals
 for the full calculation, whichever is less.
<br><br>
 This dimension however can be changed by making use of this
 variable. Note that <tt>LCAODimension</tt> cannot be smaller than the
 number of orbitals needed in the full calculation -- if
 <tt>LCAODimension</tt> is smaller, it will be silently increased to meet
 this requirement. In the same way, if <tt>LCAODimension</tt> is larger
 than the available number of atomic orbitals, it will be
 reduced. If you want to use the largest possible number, set
 <tt>LCAODimension</tt> to a negative number.

</p><hr width='30%' align='left'/>


<p><b><a name='LCAOExtraOrbitals'></a>LCAOExtraOrbitals</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Only applies if <tt>LCAOAlternative = true</tt>, and all species are pseudopotentials.
 (experimental) If this variable is set to yes, the LCAO
 procedure will add an extra set of numerical orbitals (by
 using the derivative of the radial part of the original
 orbitals). Note that this corresponds roughly to adding orbitals
 with higher principal quantum numbers, but the same angular momentum.
 This option may cause problems for unoccupied states since you may miss
 some lower-lying states which correspond to higher angular momenta instead
 of higher principal quantum number.

</p><hr width='30%' align='left'/>


<p><b><a name='LCAOKeepOrbitals'></a>LCAOKeepOrbitals</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: logical
<br/><i>Default</i>: yes
<br/><br> Only applies if <tt>LCAOAlternative = true</tt>.
 If set to yes (the default) Octopus keeps atomic orbitals in
 memory during the LCAO procedure. If set to no, the orbitals
 are generated each time that they are needed, increasing
 computational time but saving memory.
<br><br>
 When set to yes, Octopus prints the amount of memory per node
 that is required to store the orbitals.
<br><br>

</p><hr width='30%' align='left'/>


<p><b><a name='LCAOMaximumOrbitalRadius'></a>LCAOMaximumOrbitalRadius</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: float
<br/><i>Default</i>: 20.0 a.u.
<br/><br> The LCAO procedure will ignore orbitals that have an
 extent greater that this value.

</p><hr width='30%' align='left'/>


<p><b><a name='LCAOScaleFactor'></a>LCAOScaleFactor</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: float
<br/><i>Default</i>: 1.0
<br/><br> The coordinates of the atomic orbitals used by the LCAO
 procedure will be rescaled by the value of this variable. 1.0 means no rescaling.

</p><hr width='30%' align='left'/>


<p><b><a name='LCAOStart'></a>LCAOStart</b>
<br/><i>Section</i>: SCF::LCAO
<br/><i>Type</i>: integer
<br/><br> Before starting a SCF calculation, <tt>Octopus</tt> can perform
 a linear combination of atomic orbitals (LCAO) calculation.
 These can provide <tt>Octopus</tt> with a good set
 of initial wavefunctions and with a new guess for the density.
 (Up to the current version, only a minimal basis set is used.)
 The default is <tt>lcao_full</tt> if at least one species representing an atom is present.
 The default is <tt>lcao_none</tt> if all species are <tt>species_user_defined</tt>,
 <tt>species_charge_density</tt>, <tt>species_from_file</tt>, or <tt>species_jellium_slab</tt>.
<br><br>
 The initial guess densities for LCAO are taken from the atomic orbitals for pseudopotential species;
 from the natural charge density for <tt>species_charge_density</tt>, <tt>species_point</tt>,
 <tt>species_jellium</tt>, and <tt>species_jellium_slab</tt>;
 or uniform for <tt>species_full_delta</tt>, <tt>species_full_gaussian</tt>,
 <tt>species_user_defined</tt>, or <tt>species_from_file</tt>.
 Pseudopotential species use the pseudo-wavefunctions as orbitals, full-potential atomic species
 (<tt>species_full_delta</tt> and <tt>species_full_gaussian</tt>) use hydrogenic wavefunctions, and
 others use harmonic-oscillator wavefunctions.
<br><br>
 Note: Some pseudopotential files (CPI, FHI for example) do not
 contain full information about the orbitals. In this case,
 Octopus generates the starting density from the normalized
 square root of the local potential. If no orbitals are
 available at all from the pseudopotential files, Octopus will
 not be able to perform an LCAO and the initial states will be
 randomized.
<br><br>

<br/><i>Options</i>:
<ul>
<li><b>lcao_none</b>:  Do not perform a LCAO calculation before the SCF cycle. Instead use random wavefunctions.
</li>
<li><b>lcao_states</b>:  Do a LCAO calculation before the SCF cycle and use the resulting wavefunctions as
 initial wavefunctions without changing the guess density.
 This will speed up the convergence of the eigensolver during the first SCF iterations.
</li>
<li><b>lcao_full</b>:  Do a LCAO calculation before the SCF cycle and use the LCAO wavefunctions to build a new
 guess density and a new KS potential.
 Using the LCAO density as a new guess density may improve the convergence, but can
 also slow it down or yield wrong results (especially for spin-polarized calculations).
</li>
<li><b>lcao_simple</b>:  States are initialized using atomic orbitals. This produces a
 less optimal starting point, but it is faster and uses less
 memory than other methods.
</li>
</ul>
</p><hr width='30%' align='left'/>

<a name='SCF::Mixing'</a>
<H2>SCF::Mixing</H2>


<p><b><a name='MixField'></a>MixField</b>
<br/><i>Section</i>: SCF::Mixing
<br/><i>Type</i>: integer
<br/><br> Selects what should be mixed during the SCF cycle.  Note that
 currently the exact-exchange part of hybrid functionals is not
 mixed at all, which would require wavefunction-mixing, not yet
 implemented. This may lead to instabilities in the SCF cycle,
 so starting from a converged LDA/GGA calculation is recommended
 for hybrid functionals. The default depends on the <tt>TheoryLevel</tt>
 and the exchange-correlation potential used.

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  No mixing is done. This is the default for independent
 particles.
</li>
<li><b>potential</b>:  The Kohn-Sham potential is mixed. This is the default for other cases.
</li>
<li><b>density</b>:  Mix the density.
</li>
<li><b>states</b>:  (Experimental) Mix the states. In this case, the mixing is always linear.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='MixInterval'></a>MixInterval</b>
<br/><i>Section</i>: SCF::Mixing
<br/><i>Type</i>: integer
<br/><i>Default</i>: 1
<br/><br> When this variable is set to a value different than 1 (the
 defaul) a combined mixing scheme will be used, with MixInterval
 - 1 steps of linear mixing followed by 1 step of the selected
 mixing. For the moment this variable only works with DIIS mixing.

</p><hr width='30%' align='left'/>


<p><b><a name='MixNumberSteps'></a>MixNumberSteps</b>
<br/><i>Section</i>: SCF::Mixing
<br/><i>Type</i>: integer
<br/><i>Default</i>: 3
<br/><br> In the Broyden and Bowler_Gillan schemes, the new input density or potential is constructed
 from the values of the densities/potentials of a given number of previous iterations.
 This number is set by this variable. Must be greater than 1.

</p><hr width='30%' align='left'/>


<p><b><a name='Mixing'></a>Mixing</b>
<br/><i>Section</i>: SCF::Mixing
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.3
<br/><br> The linear, Broyden and DIIS scheme depend on a "mixing parameter", set by this variable.
 Must be 0 < <tt>Mixing</tt> <= 1.

</p><hr width='30%' align='left'/>


<p><b><a name='MixingPreconditioner'></a>MixingPreconditioner</b>
<br/><i>Section</i>: SCF::Mixing
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> (Experimental) If set to yes, Octopus will use a preconditioner
 for the mixing operator.

</p><hr width='30%' align='left'/>


<p><b><a name='MixingResidual'></a>MixingResidual</b>
<br/><i>Section</i>: SCF::Mixing
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.05
<br/><br> In the DIIS mixing it is benefitial to include a bit of
 residual into the mixing. This parameter controls this amount.

</p><hr width='30%' align='left'/>


<p><b><a name='MixingScheme'></a>MixingScheme</b>
<br/><i>Section</i>: SCF::Mixing
<br/><i>Type</i>: integer
<br/><i>Default</i>: broyden
<br/><br> The scheme used to produce, at each iteration in the self-consistent cycle
 that attempts to solve the Kohn-Sham equations, the input density from the value
 of the input and output densities of previous iterations.

<br/><i>Options</i>:
<ul>
<li><b>linear</b>:  Simple linear mixing.
</li>
<li><b>bowler_gillan</b>:  The Guaranteed-reduction modification of the Pulay scheme by
 Bowler and Gillan [D. R. Bowler and M. J. Gillan,
 <i>Chem. Phys.  Lett.</i> <b>325</b>, 473 (2000)].
</li>
<li><b>broyden</b>:  Broyden scheme [C. G Broyden, <i>Math. Comp.</i> <b>19</b>, 577 (1965);
 D. D. Johnson, <i>Phys. Rev. B</i> <b>38</b>, 12807 (1988)].
 For complex functions (e.g. Sternheimer with <tt>EMEta</tt> > 0), we use the generalization
 with a complex dot product.
</li>
<li><b>diis</b>:  Direct inversion in the iterative subspace (diis)
 scheme [P. Pulay, <i>Chem. Phys. Lett.</i>, <b>73</b>, 393
 (1980)] as described in [G. Kresse, and J. Hurthmueller,
 <i>Phys. Rev. B</i> <b>54</b>, 11169 (1996)].
</li>
</ul>
</p><hr width='30%' align='left'/>

<a name='SCF::RDMFT'</a>
<H2>SCF::RDMFT</H2>


<p><b><a name='RDMBasis'></a>RDMBasis</b>
<br/><i>Section</i>: SCF::RDMFT
<br/><i>Type</i>: logical
<br/><i>Default</i>: yes
<br/><br> If true, all the energy terms and corresponding derivatives involved in RDMFT will
 not be calculated on the grid but on the basis of the initial orbitals

</p><hr width='30%' align='left'/>


<p><b><a name='RDMConvEner'></a>RDMConvEner</b>
<br/><i>Section</i>: SCF::RDMFT
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-6 Ha
<br/><br> Convergence criterion for stopping the overall minimization of the energy with
 respect to occupation numbers and the orbitals. The minimization of the
 energy stops when the total energy difference between two subsequent
 minimizations of the energy with respect to the occupation numbers and the
 orbitals is smaller than this criterion. It is also used to exit the orbital minimization.

</p><hr width='30%' align='left'/>


<p><b><a name='RDMTolerance'></a>RDMTolerance</b>
<br/><i>Section</i>: SCF::RDMFT
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-7 Ha
<br/><br> Convergence criterion for stopping the occupation numbers minimization. Minimization is
 stopped when all derivatives of the energy wrt. each occupation number
 are smaller than this criterion. The bisection for finding the correct mu that is needed
 for the occupation number minimization also stops according to this criterion.

</p><hr width='30%' align='left'/>

</body>
</html>